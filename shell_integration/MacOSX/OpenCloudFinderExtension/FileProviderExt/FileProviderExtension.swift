/*
 * Copyright (C) 2025 OpenCloud GmbH
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 */

import FileProvider
import OSLog

/// Main FileProvider extension class implementing NSFileProviderReplicatedExtension.
/// This extension provides on-demand file sync capabilities for OpenCloud on macOS.
@objc class FileProviderExtension: NSObject, NSFileProviderReplicatedExtension {
    
    let domain: NSFileProviderDomain
    let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "eu.opencloud.desktopclient.FileProviderExt", category: "FileProviderExtension")
    
    // Account information received from main app
    var serverUrl: String?
    var username: String?
    var userId: String?
    
    // Socket client for communication with main app
    lazy var socketClient: LocalSocketClient? = {
        guard let containerUrl = FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: appGroupIdentifier) else {
            logger.error("Cannot get container URL for app group: \(self.appGroupIdentifier)")
            return nil
        }
        
        let socketPath = containerUrl.appendingPathComponent(".fileprovidersocket").path
        let lineProcessor = FileProviderSocketLineProcessor(delegate: self)
        return LocalSocketClient(socketPath: socketPath, lineProcessor: lineProcessor)
    }()
    
    // App group identifier - must match the main app's app group
    var appGroupIdentifier: String {
        // Read from Info.plist or use default
        return Bundle.main.object(forInfoDictionaryKey: "AppGroupIdentifier") as? String ?? "group.eu.opencloud.desktopclient"
    }
    
    // MARK: - Initialization
    
    required init(domain: NSFileProviderDomain) {
        self.domain = domain
        super.init()
        
        logger.info("Initializing FileProviderExtension for domain: \(domain.identifier.rawValue)")
        
        // Start socket connection to main app
        socketClient?.start()
    }
    
    func invalidate() {
        logger.info("FileProviderExtension invalidated for domain: \(self.domain.identifier.rawValue)")
        socketClient?.closeConnection()
    }
    
    // MARK: - NSFileProviderReplicatedExtension Protocol
    
    func item(for identifier: NSFileProviderItemIdentifier, request: NSFileProviderRequest, completionHandler: @escaping (NSFileProviderItem?, Error?) -> Void) -> Progress {
        logger.debug("Requesting item for identifier: \(identifier.rawValue)")
        
        let progress = Progress(totalUnitCount: 1)
        
        // For PoC: return hardcoded items
        if identifier == .rootContainer {
            completionHandler(FileProviderItem.rootContainer(), nil)
        } else if let item = FileProviderItem.demoItem(identifier: identifier) {
            completionHandler(item, nil)
        } else {
            completionHandler(nil, NSError.fileProviderErrorForNonExistentItem(withIdentifier: identifier))
        }
        
        progress.completedUnitCount = 1
        return progress
    }
    
    func fetchContents(for itemIdentifier: NSFileProviderItemIdentifier, version requestedVersion: NSFileProviderItemVersion?, request: NSFileProviderRequest, completionHandler: @escaping (URL?, NSFileProviderItem?, Error?) -> Void) -> Progress {
        logger.info("Fetching contents for item: \(itemIdentifier.rawValue)")
        
        let progress = Progress(totalUnitCount: 100)
        
        // For PoC: Create a temporary file with demo content
        Task {
            do {
                guard let item = FileProviderItem.demoItem(identifier: itemIdentifier) else {
                    completionHandler(nil, nil, NSError.fileProviderErrorForNonExistentItem(withIdentifier: itemIdentifier))
                    return
                }
                
                // Create temp file with demo content
                let tempDir = FileManager.default.temporaryDirectory
                let tempFile = tempDir.appendingPathComponent(item.filename)
                
                let demoContent = "This is demo content for \(item.filename)\nGenerated by OpenCloud FileProvider PoC"
                try demoContent.write(to: tempFile, atomically: true, encoding: .utf8)
                
                progress.completedUnitCount = 100
                completionHandler(tempFile, item, nil)
                
            } catch {
                logger.error("Failed to create temp file: \(error.localizedDescription)")
                completionHandler(nil, nil, error)
            }
        }
        
        return progress
    }
    
    func createItem(basedOn itemTemplate: NSFileProviderItem, fields: NSFileProviderItemFields, contents url: URL?, options: NSFileProviderCreateItemOptions = [], request: NSFileProviderRequest, completionHandler: @escaping (NSFileProviderItem?, NSFileProviderItemFields, Bool, Error?) -> Void) -> Progress {
        logger.info("Creating item: \(itemTemplate.filename)")
        
        // For PoC: Just acknowledge creation without actually creating
        let progress = Progress(totalUnitCount: 1)
        
        // Return the item as-is for now
        completionHandler(itemTemplate, [], false, nil)
        progress.completedUnitCount = 1
        
        return progress
    }
    
    func modifyItem(_ item: NSFileProviderItem, baseVersion: NSFileProviderItemVersion, changedFields: NSFileProviderItemFields, contents newContents: URL?, options: NSFileProviderModifyItemOptions = [], request: NSFileProviderRequest, completionHandler: @escaping (NSFileProviderItem?, NSFileProviderItemFields, Bool, Error?) -> Void) -> Progress {
        logger.info("Modifying item: \(item.filename)")
        
        let progress = Progress(totalUnitCount: 1)
        
        // For PoC: Just acknowledge modification
        completionHandler(item, [], false, nil)
        progress.completedUnitCount = 1
        
        return progress
    }
    
    func deleteItem(identifier: NSFileProviderItemIdentifier, baseVersion: NSFileProviderItemVersion, options: NSFileProviderDeleteItemOptions = [], request: NSFileProviderRequest, completionHandler: @escaping (Error?) -> Void) -> Progress {
        logger.info("Deleting item: \(identifier.rawValue)")
        
        let progress = Progress(totalUnitCount: 1)
        
        // For PoC: Just acknowledge deletion
        completionHandler(nil)
        progress.completedUnitCount = 1
        
        return progress
    }
    
    func enumerator(for containerItemIdentifier: NSFileProviderItemIdentifier, request: NSFileProviderRequest) throws -> NSFileProviderEnumerator {
        logger.debug("Creating enumerator for container: \(containerItemIdentifier.rawValue)")
        
        return FileProviderEnumerator(enumeratedItemIdentifier: containerItemIdentifier, domain: domain)
    }
    
    // MARK: - Communication with Main App
    
    func sendDomainIdentifier() {
        let message = "FILE_PROVIDER_DOMAIN_IDENTIFIER_REQUEST_REPLY:\(domain.identifier.rawValue)\n"
        socketClient?.sendMessage(message)
    }
    
    func setupAccount(user: String, userId: String, serverUrl: String, password: String) {
        logger.info("Setting up account for user: \(user) at server: \(serverUrl)")
        
        self.username = user
        self.userId = userId
        self.serverUrl = serverUrl
        
        // Signal that we're ready to enumerate
        signalEnumerator()
    }
    
    func signalEnumerator() {
        guard let manager = NSFileProviderManager(for: domain) else {
            logger.error("Could not get NSFileProviderManager for domain")
            return
        }
        
        manager.signalEnumerator(for: .workingSet) { error in
            if let error = error {
                self.logger.error("Error signaling enumerator: \(error.localizedDescription)")
            }
        }
    }
}
